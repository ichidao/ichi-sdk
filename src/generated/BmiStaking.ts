/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace IBMICoverStaking {
  export type PolicyBookInfoStruct = {
    totalStakedSTBL: PromiseOrValue<BigNumberish>;
    rewardPerBlock: PromiseOrValue<BigNumberish>;
    stakingAPY: PromiseOrValue<BigNumberish>;
    liquidityAPY: PromiseOrValue<BigNumberish>;
  };

  export type PolicyBookInfoStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    totalStakedSTBL: BigNumber;
    rewardPerBlock: BigNumber;
    stakingAPY: BigNumber;
    liquidityAPY: BigNumber;
  };

  export type UserInfoStruct = {
    totalStakedBMIX: PromiseOrValue<BigNumberish>;
    totalStakedSTBL: PromiseOrValue<BigNumberish>;
    totalBmiReward: PromiseOrValue<BigNumberish>;
  };

  export type UserInfoStructOutput = [BigNumber, BigNumber, BigNumber] & {
    totalStakedBMIX: BigNumber;
    totalStakedSTBL: BigNumber;
    totalBmiReward: BigNumber;
  };

  export type NFTsInfoStruct = {
    nftIndex: PromiseOrValue<BigNumberish>;
    uri: PromiseOrValue<string>;
    stakedBMIXAmount: PromiseOrValue<BigNumberish>;
    stakedSTBLAmount: PromiseOrValue<BigNumberish>;
    reward: PromiseOrValue<BigNumberish>;
  };

  export type NFTsInfoStructOutput = [
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    nftIndex: BigNumber;
    uri: string;
    stakedBMIXAmount: BigNumber;
    stakedSTBLAmount: BigNumber;
    reward: BigNumber;
  };

  export type StakingInfoStruct = {
    policyBookAddress: PromiseOrValue<string>;
    stakedBMIXAmount: PromiseOrValue<BigNumberish>;
  };

  export type StakingInfoStructOutput = [string, BigNumber] & {
    policyBookAddress: string;
    stakedBMIXAmount: BigNumber;
  };
}

export interface BmiStakingInterface extends utils.Interface {
  functions: {
    "EXIT_FEE_DURATION()": FunctionFragment;
    "MAX_EXIT_FEE()": FunctionFragment;
    "MIN_EXIT_FEE()": FunctionFragment;
    "__BMICoverStaking_init()": FunctionFragment;
    "aggregateNFTs(address,uint256[])": FunctionFragment;
    "balanceOf(address,uint256)": FunctionFragment;
    "balanceOf(address)": FunctionFragment;
    "balanceOfBatch(address[],uint256[])": FunctionFragment;
    "bmiStaking()": FunctionFragment;
    "bmiToken()": FunctionFragment;
    "getBMIProfit(uint256)": FunctionFragment;
    "getPolicyBookAPY(address)": FunctionFragment;
    "getSlashedBMIProfit(uint256)": FunctionFragment;
    "getSlashedStakerBMIProfit(address,address,uint256,uint256)": FunctionFragment;
    "getSlashingPercentage(uint256)": FunctionFragment;
    "getSlashingPercentage()": FunctionFragment;
    "getStakerBMIProfit(address,address,uint256,uint256)": FunctionFragment;
    "injector()": FunctionFragment;
    "isApprovedForAll(address,address)": FunctionFragment;
    "liquidityMining()": FunctionFragment;
    "liquidityRegistry()": FunctionFragment;
    "owner()": FunctionFragment;
    "ownerOf(uint256)": FunctionFragment;
    "policyBookByNFT(uint256)": FunctionFragment;
    "policyBookRegistry()": FunctionFragment;
    "recoverTokens()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "restakeBMIProfit(uint256)": FunctionFragment;
    "restakeStakerBMIProfit(address)": FunctionFragment;
    "rewardsGenerator()": FunctionFragment;
    "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "safeTransferFrom(address,address,uint256,uint256,bytes)": FunctionFragment;
    "setApprovalForAll(address,bool)": FunctionFragment;
    "setBaseURI(string)": FunctionFragment;
    "setDependencies(address)": FunctionFragment;
    "setInjector(address)": FunctionFragment;
    "stakeBMIX(uint256,address)": FunctionFragment;
    "stakeBMIXFrom(address,uint256)": FunctionFragment;
    "stakeBMIXFromWithPermit(address,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "stakeBMIXWithPermit(uint256,address,uint8,bytes32,bytes32)": FunctionFragment;
    "stakedByNFT(uint256)": FunctionFragment;
    "stakedSTBLByNFT(uint256)": FunctionFragment;
    "stakingInfoByStaker(address,address[],uint256,uint256)": FunctionFragment;
    "stakingInfoByToken(uint256)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "tokenOfOwnerByIndex(address,uint256)": FunctionFragment;
    "totalStaked(address)": FunctionFragment;
    "totalStakedSTBL(address)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "uri(uint256)": FunctionFragment;
    "withdrawBMIProfit(uint256)": FunctionFragment;
    "withdrawFundsWithProfit(uint256)": FunctionFragment;
    "withdrawStakerBMIProfit(address)": FunctionFragment;
    "withdrawStakerFundsWithProfit(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "EXIT_FEE_DURATION"
      | "MAX_EXIT_FEE"
      | "MIN_EXIT_FEE"
      | "__BMICoverStaking_init"
      | "aggregateNFTs"
      | "balanceOf(address,uint256)"
      | "balanceOf(address)"
      | "balanceOfBatch"
      | "bmiStaking"
      | "bmiToken"
      | "getBMIProfit"
      | "getPolicyBookAPY"
      | "getSlashedBMIProfit"
      | "getSlashedStakerBMIProfit"
      | "getSlashingPercentage(uint256)"
      | "getSlashingPercentage()"
      | "getStakerBMIProfit"
      | "injector"
      | "isApprovedForAll"
      | "liquidityMining"
      | "liquidityRegistry"
      | "owner"
      | "ownerOf"
      | "policyBookByNFT"
      | "policyBookRegistry"
      | "recoverTokens"
      | "renounceOwnership"
      | "restakeBMIProfit"
      | "restakeStakerBMIProfit"
      | "rewardsGenerator"
      | "safeBatchTransferFrom"
      | "safeTransferFrom"
      | "setApprovalForAll"
      | "setBaseURI"
      | "setDependencies"
      | "setInjector"
      | "stakeBMIX"
      | "stakeBMIXFrom"
      | "stakeBMIXFromWithPermit"
      | "stakeBMIXWithPermit"
      | "stakedByNFT"
      | "stakedSTBLByNFT"
      | "stakingInfoByStaker"
      | "stakingInfoByToken"
      | "supportsInterface"
      | "tokenOfOwnerByIndex"
      | "totalStaked"
      | "totalStakedSTBL"
      | "transferOwnership"
      | "uri"
      | "withdrawBMIProfit"
      | "withdrawFundsWithProfit"
      | "withdrawStakerBMIProfit"
      | "withdrawStakerFundsWithProfit"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "EXIT_FEE_DURATION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_EXIT_FEE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_EXIT_FEE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "__BMICoverStaking_init",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "aggregateNFTs",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf(address,uint256)",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf(address)",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOfBatch",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "bmiStaking",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "bmiToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getBMIProfit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPolicyBookAPY",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSlashedBMIProfit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSlashedStakerBMIProfit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getSlashingPercentage(uint256)",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSlashingPercentage()",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStakerBMIProfit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(functionFragment: "injector", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidityMining",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "liquidityRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ownerOf",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "policyBookByNFT",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "policyBookRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "recoverTokens",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "restakeBMIProfit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "restakeStakerBMIProfit",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "rewardsGenerator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "safeBatchTransferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBaseURI",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setDependencies",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setInjector",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakeBMIX",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakeBMIXFrom",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakeBMIXFromWithPermit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stakeBMIXWithPermit",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stakedByNFT",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakedSTBLByNFT",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakingInfoByStaker",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stakingInfoByToken",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenOfOwnerByIndex",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalStaked",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalStakedSTBL",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "uri",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawBMIProfit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawFundsWithProfit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawStakerBMIProfit",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawStakerFundsWithProfit",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "EXIT_FEE_DURATION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_EXIT_FEE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_EXIT_FEE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "__BMICoverStaking_init",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "aggregateNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceOf(address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceOf(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceOfBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "bmiStaking", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bmiToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getBMIProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPolicyBookAPY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSlashedBMIProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSlashedStakerBMIProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSlashingPercentage(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSlashingPercentage()",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakerBMIProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "injector", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidityMining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidityRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "ownerOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "policyBookByNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "policyBookRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recoverTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "restakeBMIProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "restakeStakerBMIProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rewardsGenerator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeBatchTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setBaseURI", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setDependencies",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setInjector",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stakeBMIX", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stakeBMIXFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakeBMIXFromWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakeBMIXWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakedByNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakedSTBLByNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakingInfoByStaker",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakingInfoByToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenOfOwnerByIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalStakedSTBL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "uri", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawBMIProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawFundsWithProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawStakerBMIProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawStakerFundsWithProfit",
    data: BytesLike
  ): Result;

  events: {
    "ApprovalForAll(address,address,bool)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "StakingBMIProfitWithdrawn(uint256,address,address,uint256)": EventFragment;
    "StakingFundsWithdrawn(uint256,address,address,uint256)": EventFragment;
    "StakingNFTBurned(uint256,address)": EventFragment;
    "StakingNFTMinted(uint256,address,address)": EventFragment;
    "TokensRecovered(address,uint256)": EventFragment;
    "TransferBatch(address,address,address,uint256[],uint256[])": EventFragment;
    "TransferSingle(address,address,address,uint256,uint256)": EventFragment;
    "URI(string,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ApprovalForAll"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakingBMIProfitWithdrawn"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakingFundsWithdrawn"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakingNFTBurned"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakingNFTMinted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokensRecovered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferBatch"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferSingle"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "URI"): EventFragment;
}

export interface ApprovalForAllEventObject {
  account: string;
  operator: string;
  approved: boolean;
}
export type ApprovalForAllEvent = TypedEvent<
  [string, string, boolean],
  ApprovalForAllEventObject
>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface StakingBMIProfitWithdrawnEventObject {
  id: BigNumber;
  policyBookAddress: string;
  to: string;
  amount: BigNumber;
}
export type StakingBMIProfitWithdrawnEvent = TypedEvent<
  [BigNumber, string, string, BigNumber],
  StakingBMIProfitWithdrawnEventObject
>;

export type StakingBMIProfitWithdrawnEventFilter =
  TypedEventFilter<StakingBMIProfitWithdrawnEvent>;

export interface StakingFundsWithdrawnEventObject {
  id: BigNumber;
  policyBookAddress: string;
  to: string;
  amount: BigNumber;
}
export type StakingFundsWithdrawnEvent = TypedEvent<
  [BigNumber, string, string, BigNumber],
  StakingFundsWithdrawnEventObject
>;

export type StakingFundsWithdrawnEventFilter =
  TypedEventFilter<StakingFundsWithdrawnEvent>;

export interface StakingNFTBurnedEventObject {
  id: BigNumber;
  policyBookAddress: string;
}
export type StakingNFTBurnedEvent = TypedEvent<
  [BigNumber, string],
  StakingNFTBurnedEventObject
>;

export type StakingNFTBurnedEventFilter =
  TypedEventFilter<StakingNFTBurnedEvent>;

export interface StakingNFTMintedEventObject {
  id: BigNumber;
  policyBookAddress: string;
  to: string;
}
export type StakingNFTMintedEvent = TypedEvent<
  [BigNumber, string, string],
  StakingNFTMintedEventObject
>;

export type StakingNFTMintedEventFilter =
  TypedEventFilter<StakingNFTMintedEvent>;

export interface TokensRecoveredEventObject {
  to: string;
  amount: BigNumber;
}
export type TokensRecoveredEvent = TypedEvent<
  [string, BigNumber],
  TokensRecoveredEventObject
>;

export type TokensRecoveredEventFilter = TypedEventFilter<TokensRecoveredEvent>;

export interface TransferBatchEventObject {
  operator: string;
  from: string;
  to: string;
  ids: BigNumber[];
  values: BigNumber[];
}
export type TransferBatchEvent = TypedEvent<
  [string, string, string, BigNumber[], BigNumber[]],
  TransferBatchEventObject
>;

export type TransferBatchEventFilter = TypedEventFilter<TransferBatchEvent>;

export interface TransferSingleEventObject {
  operator: string;
  from: string;
  to: string;
  id: BigNumber;
  value: BigNumber;
}
export type TransferSingleEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  TransferSingleEventObject
>;

export type TransferSingleEventFilter = TypedEventFilter<TransferSingleEvent>;

export interface URIEventObject {
  value: string;
  id: BigNumber;
}
export type URIEvent = TypedEvent<[string, BigNumber], URIEventObject>;

export type URIEventFilter = TypedEventFilter<URIEvent>;

export interface BmiStaking extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: BmiStakingInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    EXIT_FEE_DURATION(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_EXIT_FEE(overrides?: CallOverrides): Promise<[BigNumber]>;

    MIN_EXIT_FEE(overrides?: CallOverrides): Promise<[BigNumber]>;

    __BMICoverStaking_init(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    aggregateNFTs(
      policyBookAddress: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "balanceOf(address,uint256)"(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "balanceOf(address)"(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    bmiStaking(overrides?: CallOverrides): Promise<[string]>;

    bmiToken(overrides?: CallOverrides): Promise<[string]>;

    getBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getPolicyBookAPY(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getSlashedBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getSlashedStakerBMIProfit(
      staker: PromiseOrValue<string>,
      policyBookAddress: PromiseOrValue<string>,
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { totalProfit: BigNumber }>;

    "getSlashingPercentage(uint256)"(
      startTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "getSlashingPercentage()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    getStakerBMIProfit(
      staker: PromiseOrValue<string>,
      policyBookAddress: PromiseOrValue<string>,
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    injector(
      overrides?: CallOverrides
    ): Promise<[string] & { _injector: string }>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    liquidityMining(overrides?: CallOverrides): Promise<[string]>;

    liquidityRegistry(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    ownerOf(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    policyBookByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    policyBookRegistry(overrides?: CallOverrides): Promise<[string]>;

    recoverTokens(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    restakeBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    restakeStakerBMIProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rewardsGenerator(overrides?: CallOverrides): Promise<[string]>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBaseURI(
      newURI: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setDependencies(
      _contractsRegistry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setInjector(
      _injector: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakeBMIX(
      bmiXAmount: PromiseOrValue<BigNumberish>,
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakeBMIXFrom(
      user: PromiseOrValue<string>,
      bmiXAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakeBMIXFromWithPermit(
      user: PromiseOrValue<string>,
      bmiXAmount: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakeBMIXWithPermit(
      bmiXAmount: PromiseOrValue<BigNumberish>,
      policyBookAddress: PromiseOrValue<string>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakedByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    stakedSTBLByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    stakingInfoByStaker(
      staker: PromiseOrValue<string>,
      policyBooksAddresses: PromiseOrValue<string>[],
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        IBMICoverStaking.PolicyBookInfoStructOutput[],
        IBMICoverStaking.UserInfoStructOutput[],
        BigNumber[],
        IBMICoverStaking.NFTsInfoStructOutput[][]
      ] & {
        policyBooksInfo: IBMICoverStaking.PolicyBookInfoStructOutput[];
        usersInfo: IBMICoverStaking.UserInfoStructOutput[];
        nftsCount: BigNumber[];
        nftsInfo: IBMICoverStaking.NFTsInfoStructOutput[][];
      }
    >;

    stakingInfoByToken(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[IBMICoverStaking.StakingInfoStructOutput]>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    tokenOfOwnerByIndex(
      user: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    totalStaked(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    totalStakedSTBL(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    uri(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    withdrawBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawFundsWithProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawStakerBMIProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawStakerFundsWithProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  EXIT_FEE_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_EXIT_FEE(overrides?: CallOverrides): Promise<BigNumber>;

  MIN_EXIT_FEE(overrides?: CallOverrides): Promise<BigNumber>;

  __BMICoverStaking_init(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  aggregateNFTs(
    policyBookAddress: PromiseOrValue<string>,
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "balanceOf(address,uint256)"(
    account: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "balanceOf(address)"(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  balanceOfBatch(
    accounts: PromiseOrValue<string>[],
    ids: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  bmiStaking(overrides?: CallOverrides): Promise<string>;

  bmiToken(overrides?: CallOverrides): Promise<string>;

  getBMIProfit(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getPolicyBookAPY(
    policyBookAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getSlashedBMIProfit(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getSlashedStakerBMIProfit(
    staker: PromiseOrValue<string>,
    policyBookAddress: PromiseOrValue<string>,
    offset: PromiseOrValue<BigNumberish>,
    limit: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getSlashingPercentage(uint256)"(
    startTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getSlashingPercentage()"(overrides?: CallOverrides): Promise<BigNumber>;

  getStakerBMIProfit(
    staker: PromiseOrValue<string>,
    policyBookAddress: PromiseOrValue<string>,
    offset: PromiseOrValue<BigNumberish>,
    limit: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  injector(overrides?: CallOverrides): Promise<string>;

  isApprovedForAll(
    account: PromiseOrValue<string>,
    operator: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  liquidityMining(overrides?: CallOverrides): Promise<string>;

  liquidityRegistry(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  ownerOf(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  policyBookByNFT(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  policyBookRegistry(overrides?: CallOverrides): Promise<string>;

  recoverTokens(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  restakeBMIProfit(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  restakeStakerBMIProfit(
    policyBookAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rewardsGenerator(overrides?: CallOverrides): Promise<string>;

  safeBatchTransferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    ids: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  safeTransferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setApprovalForAll(
    operator: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBaseURI(
    newURI: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setDependencies(
    _contractsRegistry: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setInjector(
    _injector: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakeBMIX(
    bmiXAmount: PromiseOrValue<BigNumberish>,
    policyBookAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakeBMIXFrom(
    user: PromiseOrValue<string>,
    bmiXAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakeBMIXFromWithPermit(
    user: PromiseOrValue<string>,
    bmiXAmount: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakeBMIXWithPermit(
    bmiXAmount: PromiseOrValue<BigNumberish>,
    policyBookAddress: PromiseOrValue<string>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakedByNFT(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  stakedSTBLByNFT(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  stakingInfoByStaker(
    staker: PromiseOrValue<string>,
    policyBooksAddresses: PromiseOrValue<string>[],
    offset: PromiseOrValue<BigNumberish>,
    limit: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      IBMICoverStaking.PolicyBookInfoStructOutput[],
      IBMICoverStaking.UserInfoStructOutput[],
      BigNumber[],
      IBMICoverStaking.NFTsInfoStructOutput[][]
    ] & {
      policyBooksInfo: IBMICoverStaking.PolicyBookInfoStructOutput[];
      usersInfo: IBMICoverStaking.UserInfoStructOutput[];
      nftsCount: BigNumber[];
      nftsInfo: IBMICoverStaking.NFTsInfoStructOutput[][];
    }
  >;

  stakingInfoByToken(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IBMICoverStaking.StakingInfoStructOutput>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  tokenOfOwnerByIndex(
    user: PromiseOrValue<string>,
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalStaked(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalStakedSTBL(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  uri(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  withdrawBMIProfit(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawFundsWithProfit(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawStakerBMIProfit(
    policyBookAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawStakerFundsWithProfit(
    policyBookAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    EXIT_FEE_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_EXIT_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_EXIT_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    __BMICoverStaking_init(overrides?: CallOverrides): Promise<void>;

    aggregateNFTs(
      policyBookAddress: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    "balanceOf(address,uint256)"(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "balanceOf(address)"(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    bmiStaking(overrides?: CallOverrides): Promise<string>;

    bmiToken(overrides?: CallOverrides): Promise<string>;

    getBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPolicyBookAPY(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSlashedBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSlashedStakerBMIProfit(
      staker: PromiseOrValue<string>,
      policyBookAddress: PromiseOrValue<string>,
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getSlashingPercentage(uint256)"(
      startTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getSlashingPercentage()"(overrides?: CallOverrides): Promise<BigNumber>;

    getStakerBMIProfit(
      staker: PromiseOrValue<string>,
      policyBookAddress: PromiseOrValue<string>,
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    injector(overrides?: CallOverrides): Promise<string>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    liquidityMining(overrides?: CallOverrides): Promise<string>;

    liquidityRegistry(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    ownerOf(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    policyBookByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    policyBookRegistry(overrides?: CallOverrides): Promise<string>;

    recoverTokens(overrides?: CallOverrides): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    restakeBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    restakeStakerBMIProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    rewardsGenerator(overrides?: CallOverrides): Promise<string>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setBaseURI(
      newURI: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setDependencies(
      _contractsRegistry: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setInjector(
      _injector: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakeBMIX(
      bmiXAmount: PromiseOrValue<BigNumberish>,
      policyBookAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakeBMIXFrom(
      user: PromiseOrValue<string>,
      bmiXAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakeBMIXFromWithPermit(
      user: PromiseOrValue<string>,
      bmiXAmount: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakeBMIXWithPermit(
      bmiXAmount: PromiseOrValue<BigNumberish>,
      policyBookAddress: PromiseOrValue<string>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakedByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stakedSTBLByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stakingInfoByStaker(
      staker: PromiseOrValue<string>,
      policyBooksAddresses: PromiseOrValue<string>[],
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        IBMICoverStaking.PolicyBookInfoStructOutput[],
        IBMICoverStaking.UserInfoStructOutput[],
        BigNumber[],
        IBMICoverStaking.NFTsInfoStructOutput[][]
      ] & {
        policyBooksInfo: IBMICoverStaking.PolicyBookInfoStructOutput[];
        usersInfo: IBMICoverStaking.UserInfoStructOutput[];
        nftsCount: BigNumber[];
        nftsInfo: IBMICoverStaking.NFTsInfoStructOutput[][];
      }
    >;

    stakingInfoByToken(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IBMICoverStaking.StakingInfoStructOutput>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    tokenOfOwnerByIndex(
      user: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalStaked(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalStakedSTBL(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    uri(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    withdrawBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawFundsWithProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawStakerBMIProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawStakerFundsWithProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ApprovalForAll(address,address,bool)"(
      account?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      account?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null
    ): ApprovalForAllEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "StakingBMIProfitWithdrawn(uint256,address,address,uint256)"(
      id?: null,
      policyBookAddress?: null,
      to?: null,
      amount?: null
    ): StakingBMIProfitWithdrawnEventFilter;
    StakingBMIProfitWithdrawn(
      id?: null,
      policyBookAddress?: null,
      to?: null,
      amount?: null
    ): StakingBMIProfitWithdrawnEventFilter;

    "StakingFundsWithdrawn(uint256,address,address,uint256)"(
      id?: null,
      policyBookAddress?: null,
      to?: null,
      amount?: null
    ): StakingFundsWithdrawnEventFilter;
    StakingFundsWithdrawn(
      id?: null,
      policyBookAddress?: null,
      to?: null,
      amount?: null
    ): StakingFundsWithdrawnEventFilter;

    "StakingNFTBurned(uint256,address)"(
      id?: null,
      policyBookAddress?: null
    ): StakingNFTBurnedEventFilter;
    StakingNFTBurned(
      id?: null,
      policyBookAddress?: null
    ): StakingNFTBurnedEventFilter;

    "StakingNFTMinted(uint256,address,address)"(
      id?: null,
      policyBookAddress?: null,
      to?: null
    ): StakingNFTMintedEventFilter;
    StakingNFTMinted(
      id?: null,
      policyBookAddress?: null,
      to?: null
    ): StakingNFTMintedEventFilter;

    "TokensRecovered(address,uint256)"(
      to?: null,
      amount?: null
    ): TokensRecoveredEventFilter;
    TokensRecovered(to?: null, amount?: null): TokensRecoveredEventFilter;

    "TransferBatch(address,address,address,uint256[],uint256[])"(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;
    TransferBatch(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;

    "TransferSingle(address,address,address,uint256,uint256)"(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;
    TransferSingle(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;

    "URI(string,uint256)"(
      value?: null,
      id?: PromiseOrValue<BigNumberish> | null
    ): URIEventFilter;
    URI(value?: null, id?: PromiseOrValue<BigNumberish> | null): URIEventFilter;
  };

  estimateGas: {
    EXIT_FEE_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_EXIT_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_EXIT_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    __BMICoverStaking_init(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    aggregateNFTs(
      policyBookAddress: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "balanceOf(address,uint256)"(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "balanceOf(address)"(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bmiStaking(overrides?: CallOverrides): Promise<BigNumber>;

    bmiToken(overrides?: CallOverrides): Promise<BigNumber>;

    getBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPolicyBookAPY(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSlashedBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSlashedStakerBMIProfit(
      staker: PromiseOrValue<string>,
      policyBookAddress: PromiseOrValue<string>,
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getSlashingPercentage(uint256)"(
      startTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getSlashingPercentage()"(overrides?: CallOverrides): Promise<BigNumber>;

    getStakerBMIProfit(
      staker: PromiseOrValue<string>,
      policyBookAddress: PromiseOrValue<string>,
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    injector(overrides?: CallOverrides): Promise<BigNumber>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidityMining(overrides?: CallOverrides): Promise<BigNumber>;

    liquidityRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    ownerOf(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    policyBookByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    policyBookRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    recoverTokens(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    restakeBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    restakeStakerBMIProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rewardsGenerator(overrides?: CallOverrides): Promise<BigNumber>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBaseURI(
      newURI: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setDependencies(
      _contractsRegistry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setInjector(
      _injector: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakeBMIX(
      bmiXAmount: PromiseOrValue<BigNumberish>,
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakeBMIXFrom(
      user: PromiseOrValue<string>,
      bmiXAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakeBMIXFromWithPermit(
      user: PromiseOrValue<string>,
      bmiXAmount: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakeBMIXWithPermit(
      bmiXAmount: PromiseOrValue<BigNumberish>,
      policyBookAddress: PromiseOrValue<string>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakedByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stakedSTBLByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stakingInfoByStaker(
      staker: PromiseOrValue<string>,
      policyBooksAddresses: PromiseOrValue<string>[],
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stakingInfoByToken(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenOfOwnerByIndex(
      user: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalStaked(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalStakedSTBL(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    uri(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdrawBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawFundsWithProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawStakerBMIProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawStakerFundsWithProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    EXIT_FEE_DURATION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_EXIT_FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MIN_EXIT_FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    __BMICoverStaking_init(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    aggregateNFTs(
      policyBookAddress: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "balanceOf(address,uint256)"(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "balanceOf(address)"(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    bmiStaking(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bmiToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPolicyBookAPY(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSlashedBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSlashedStakerBMIProfit(
      staker: PromiseOrValue<string>,
      policyBookAddress: PromiseOrValue<string>,
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getSlashingPercentage(uint256)"(
      startTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getSlashingPercentage()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStakerBMIProfit(
      staker: PromiseOrValue<string>,
      policyBookAddress: PromiseOrValue<string>,
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    injector(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidityMining(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liquidityRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ownerOf(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    policyBookByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    policyBookRegistry(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    recoverTokens(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    restakeBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    restakeStakerBMIProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rewardsGenerator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBaseURI(
      newURI: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setDependencies(
      _contractsRegistry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setInjector(
      _injector: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakeBMIX(
      bmiXAmount: PromiseOrValue<BigNumberish>,
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakeBMIXFrom(
      user: PromiseOrValue<string>,
      bmiXAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakeBMIXFromWithPermit(
      user: PromiseOrValue<string>,
      bmiXAmount: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakeBMIXWithPermit(
      bmiXAmount: PromiseOrValue<BigNumberish>,
      policyBookAddress: PromiseOrValue<string>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakedByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    stakedSTBLByNFT(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    stakingInfoByStaker(
      staker: PromiseOrValue<string>,
      policyBooksAddresses: PromiseOrValue<string>[],
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    stakingInfoByToken(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenOfOwnerByIndex(
      user: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalStaked(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalStakedSTBL(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    uri(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    withdrawBMIProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawFundsWithProfit(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawStakerBMIProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawStakerFundsWithProfit(
      policyBookAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
